/* tslint:disable */
/* eslint-disable */
/**
 * Payment Processor Service
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: info@gemini-commerce.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AvailabilityContextCustomer
 */
export interface AvailabilityContextCustomer {
    /**
     * 
     * @type {Array<string>}
     * @memberof AvailabilityContextCustomer
     */
    'segments'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AvailabilityContextCustomer
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ConditionAction = {
    Disallow: 'DISALLOW'
} as const;

export type ConditionAction = typeof ConditionAction[keyof typeof ConditionAction];


/**
 * 
 * @export
 * @interface PaymentContextOrderInfo
 */
export interface PaymentContextOrderInfo {
    /**
     * 
     * @type {string}
     * @memberof PaymentContextOrderInfo
     */
    'number': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentContextOrderInfo
     */
    'grn': string;
    /**
     * 
     * @type {Array<PaymentprocessorItem>}
     * @memberof PaymentContextOrderInfo
     */
    'items'?: Array<PaymentprocessorItem>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PaymentMethodRestrictionConditionCondition = {
    In: 'IN',
    NotIn: 'NOT_IN'
} as const;

export type PaymentMethodRestrictionConditionCondition = typeof PaymentMethodRestrictionConditionCondition[keyof typeof PaymentMethodRestrictionConditionCondition];


/**
 * 
 * @export
 * @interface PaymentprocessorAuthorizePaymentRequest
 */
export interface PaymentprocessorAuthorizePaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorAuthorizePaymentRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {PaymentprocessorPaymentContext}
     * @memberof PaymentprocessorAuthorizePaymentRequest
     */
    'context'?: PaymentprocessorPaymentContext;
    /**
     * payment type stripe, paypal..
     * @type {string}
     * @memberof PaymentprocessorAuthorizePaymentRequest
     */
    'code': string;
    /**
     * 
     * @type {PaymentprocessorMoney}
     * @memberof PaymentprocessorAuthorizePaymentRequest
     */
    'amount'?: PaymentprocessorMoney;
    /**
     * 
     * @type {PaymentprocessorCurrency}
     * @memberof PaymentprocessorAuthorizePaymentRequest
     */
    'currency'?: PaymentprocessorCurrency;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorAuthorizePaymentRequest
     */
    'additionalInfo'?: string;
}


/**
 * 
 * @export
 * @interface PaymentprocessorAuthorizePaymentResponse
 */
export interface PaymentprocessorAuthorizePaymentResponse {
    /**
     * 
     * @type {PaymentprocessorTransaction}
     * @memberof PaymentprocessorAuthorizePaymentResponse
     */
    'transaction'?: PaymentprocessorTransaction;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorAuthorizePaymentResponse
     */
    'errorMessage'?: string;
}
/**
 * 
 * @export
 * @interface PaymentprocessorAvailabilityContext
 */
export interface PaymentprocessorAvailabilityContext {
    /**
     * 
     * @type {PaymentprocessorAvailabilityContextPostalAddress}
     * @memberof PaymentprocessorAvailabilityContext
     */
    'shippingAddress'?: PaymentprocessorAvailabilityContextPostalAddress;
    /**
     * 
     * @type {PaymentprocessorAvailabilityContextPostalAddress}
     * @memberof PaymentprocessorAvailabilityContext
     */
    'billingAddress'?: PaymentprocessorAvailabilityContextPostalAddress;
    /**
     * 
     * @type {AvailabilityContextCustomer}
     * @memberof PaymentprocessorAvailabilityContext
     */
    'customer'?: AvailabilityContextCustomer;
}
/**
 * 
 * @export
 * @interface PaymentprocessorAvailabilityContextPostalAddress
 */
export interface PaymentprocessorAvailabilityContextPostalAddress {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorAvailabilityContextPostalAddress
     */
    'regionCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorAvailabilityContextPostalAddress
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorAvailabilityContextPostalAddress
     */
    'firstname'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorAvailabilityContextPostalAddress
     */
    'lastname'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PaymentprocessorAvailabilityContextPostalAddress
     */
    'addressLines'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof PaymentprocessorAvailabilityContextPostalAddress
     */
    'additionalInfo'?: object;
}
/**
 * 
 * @export
 * @interface PaymentprocessorCreatePaymentMethodRequest
 */
export interface PaymentprocessorCreatePaymentMethodRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorCreatePaymentMethodRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorCreatePaymentMethodRequest
     */
    'code': string;
    /**
     * 
     * @type {PaymentprocessorLocalizedText}
     * @memberof PaymentprocessorCreatePaymentMethodRequest
     */
    'title': PaymentprocessorLocalizedText;
    /**
     * 
     * @type {PaymentprocessorLocalizedText}
     * @memberof PaymentprocessorCreatePaymentMethodRequest
     */
    'label'?: PaymentprocessorLocalizedText;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentprocessorCreatePaymentMethodRequest
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {PaymentprocessorMoney}
     * @memberof PaymentprocessorCreatePaymentMethodRequest
     */
    'amount'?: PaymentprocessorMoney;
    /**
     * 
     * @type {PaymentprocessorCurrency}
     * @memberof PaymentprocessorCreatePaymentMethodRequest
     */
    'currency'?: PaymentprocessorCurrency;
    /**
     * 
     * @type {object}
     * @memberof PaymentprocessorCreatePaymentMethodRequest
     */
    'configuration'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentprocessorCreatePaymentMethodRequest
     */
    'isUpfront'?: boolean;
    /**
     * 
     * @type {PaymentprocessorLocalizedText}
     * @memberof PaymentprocessorCreatePaymentMethodRequest
     */
    'description'?: PaymentprocessorLocalizedText;
    /**
     * 
     * @type {Array<PaymentprocessorPaymentMethodRestriction>}
     * @memberof PaymentprocessorCreatePaymentMethodRequest
     */
    'restrictions'?: Array<PaymentprocessorPaymentMethodRestriction>;
}


/**
 * Stands for Albania, not all ;-)
 * @export
 * @enum {string}
 */

export const PaymentprocessorCurrency = {
    Xxx: 'XXX',
    All: 'ALL',
    Dzd: 'DZD',
    Ars: 'ARS',
    Aud: 'AUD',
    Bsd: 'BSD',
    Bhd: 'BHD',
    Bdt: 'BDT',
    Amd: 'AMD',
    Bbd: 'BBD',
    Bmd: 'BMD',
    Btn: 'BTN',
    Bob: 'BOB',
    Bwp: 'BWP',
    Bzd: 'BZD',
    Sbd: 'SBD',
    Bnd: 'BND',
    Mmk: 'MMK',
    Bif: 'BIF',
    Khr: 'KHR',
    Cad: 'CAD',
    Cve: 'CVE',
    Kyd: 'KYD',
    Lkr: 'LKR',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Kmf: 'KMF',
    Crc: 'CRC',
    Hrk: 'HRK',
    Cup: 'CUP',
    Czk: 'CZK',
    Dkk: 'DKK',
    Dop: 'DOP',
    Svc: 'SVC',
    Etb: 'ETB',
    Ern: 'ERN',
    Fkp: 'FKP',
    Fjd: 'FJD',
    Djf: 'DJF',
    Gmd: 'GMD',
    Gip: 'GIP',
    Gtq: 'GTQ',
    Gnf: 'GNF',
    Gyd: 'GYD',
    Htg: 'HTG',
    Hnl: 'HNL',
    Hkd: 'HKD',
    Huf: 'HUF',
    Isk: 'ISK',
    Inr: 'INR',
    Idr: 'IDR',
    Irr: 'IRR',
    Iqd: 'IQD',
    Ils: 'ILS',
    Jmd: 'JMD',
    Jpy: 'JPY',
    Kzt: 'KZT',
    Jod: 'JOD',
    Kes: 'KES',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kgs: 'KGS',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lsl: 'LSL',
    Lrd: 'LRD',
    Lyd: 'LYD',
    Ltl: 'LTL',
    Mop: 'MOP',
    Mwk: 'MWK',
    Myr: 'MYR',
    Mvr: 'MVR',
    Mro: 'MRO',
    Mur: 'MUR',
    Mxn: 'MXN',
    Mnt: 'MNT',
    Mdl: 'MDL',
    Mad: 'MAD',
    Omr: 'OMR',
    Nad: 'NAD',
    Npr: 'NPR',
    Ang: 'ANG',
    Awg: 'AWG',
    Vuv: 'VUV',
    Nzd: 'NZD',
    Nio: 'NIO',
    Ngn: 'NGN',
    Nok: 'NOK',
    Pkr: 'PKR',
    Pab: 'PAB',
    Pgk: 'PGK',
    Pyg: 'PYG',
    Pen: 'PEN',
    Php: 'PHP',
    Qar: 'QAR',
    Rub: 'RUB',
    Rwf: 'RWF',
    Shp: 'SHP',
    Std: 'STD',
    Sar: 'SAR',
    Scr: 'SCR',
    Sll: 'SLL',
    Sgd: 'SGD',
    Vnd: 'VND',
    Sos: 'SOS',
    Zar: 'ZAR',
    Ssp: 'SSP',
    Szl: 'SZL',
    Sek: 'SEK',
    Chf: 'CHF',
    Syp: 'SYP',
    Thb: 'THB',
    Top: 'TOP',
    Ttd: 'TTD',
    Aed: 'AED',
    Tnd: 'TND',
    Ugx: 'UGX',
    Mkd: 'MKD',
    Egp: 'EGP',
    Gbp: 'GBP',
    Tzs: 'TZS',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Wst: 'WST',
    Yer: 'YER',
    Twd: 'TWD',
    Cuc: 'CUC',
    Zwl: 'ZWL',
    Tmt: 'TMT',
    Ghs: 'GHS',
    Vef: 'VEF',
    Sdg: 'SDG',
    Uyi: 'UYI',
    Rsd: 'RSD',
    Mzn: 'MZN',
    Azn: 'AZN',
    Ron: 'RON',
    Che: 'CHE',
    Chw: 'CHW',
    Try: 'TRY',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xof: 'XOF',
    Xpf: 'XPF',
    Xba: 'XBA',
    Xbb: 'XBB',
    Xbc: 'XBC',
    Xbd: 'XBD',
    Xau: 'XAU',
    Xdr: 'XDR',
    Xag: 'XAG',
    Xpt: 'XPT',
    Xpd: 'XPD',
    Xua: 'XUA',
    Zmw: 'ZMW',
    Srd: 'SRD',
    Mga: 'MGA',
    Cou: 'COU',
    Afn: 'AFN',
    Tjs: 'TJS',
    Aoa: 'AOA',
    Byr: 'BYR',
    Bgn: 'BGN',
    Cdf: 'CDF',
    Bam: 'BAM',
    Eur: 'EUR',
    Mxv: 'MXV',
    Uah: 'UAH',
    Gel: 'GEL',
    Bov: 'BOV',
    Pln: 'PLN',
    Brl: 'BRL',
    Clf: 'CLF',
    Xsu: 'XSU',
    Usn: 'USN'
} as const;

export type PaymentprocessorCurrency = typeof PaymentprocessorCurrency[keyof typeof PaymentprocessorCurrency];


/**
 * 
 * @export
 * @interface PaymentprocessorFinalizePaymentRequest
 */
export interface PaymentprocessorFinalizePaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorFinalizePaymentRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorFinalizePaymentRequest
     */
    'paymentId': string;
    /**
     * 
     * @type {PaymentprocessorPaymentContext}
     * @memberof PaymentprocessorFinalizePaymentRequest
     */
    'context'?: PaymentprocessorPaymentContext;
    /**
     * payment type stripe, paypal..
     * @type {string}
     * @memberof PaymentprocessorFinalizePaymentRequest
     */
    'code': string;
    /**
     * 
     * @type {PaymentprocessorMoney}
     * @memberof PaymentprocessorFinalizePaymentRequest
     */
    'amount'?: PaymentprocessorMoney;
    /**
     * 
     * @type {PaymentprocessorCurrency}
     * @memberof PaymentprocessorFinalizePaymentRequest
     */
    'currency'?: PaymentprocessorCurrency;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorFinalizePaymentRequest
     */
    'additionalInfo'?: string;
    /**
     * 
     * @type {Array<PaymentprocessorTransaction>}
     * @memberof PaymentprocessorFinalizePaymentRequest
     */
    'transactions'?: Array<PaymentprocessorTransaction>;
}


/**
 * 
 * @export
 * @interface PaymentprocessorFinalizePaymentResponse
 */
export interface PaymentprocessorFinalizePaymentResponse {
    /**
     * 
     * @type {PaymentprocessorTransaction}
     * @memberof PaymentprocessorFinalizePaymentResponse
     */
    'transaction'?: PaymentprocessorTransaction;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorFinalizePaymentResponse
     */
    'errorMessage'?: string;
}
/**
 * 
 * @export
 * @interface PaymentprocessorGetAvailablePaymentMethodRequest
 */
export interface PaymentprocessorGetAvailablePaymentMethodRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorGetAvailablePaymentMethodRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorGetAvailablePaymentMethodRequest
     */
    'code': string;
    /**
     * 
     * @type {PaymentprocessorAvailabilityContext}
     * @memberof PaymentprocessorGetAvailablePaymentMethodRequest
     */
    'context': PaymentprocessorAvailabilityContext;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentprocessorGetAvailablePaymentMethodRequest
     */
    'authenticateMethod'?: boolean;
}
/**
 * 
 * @export
 * @interface PaymentprocessorGetPaymentMethodConfigurationRequest
 */
export interface PaymentprocessorGetPaymentMethodConfigurationRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorGetPaymentMethodConfigurationRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorGetPaymentMethodConfigurationRequest
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface PaymentprocessorGetPaymentMethodConfigurationResponse
 */
export interface PaymentprocessorGetPaymentMethodConfigurationResponse {
    /**
     * 
     * @type {object}
     * @memberof PaymentprocessorGetPaymentMethodConfigurationResponse
     */
    'configuration'?: object;
}
/**
 * 
 * @export
 * @interface PaymentprocessorGetPaymentMethodRequest
 */
export interface PaymentprocessorGetPaymentMethodRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorGetPaymentMethodRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorGetPaymentMethodRequest
     */
    'code': string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentprocessorGetPaymentMethodRequest
     */
    'authenticateMethod'?: boolean;
}
/**
 * 
 * @export
 * @interface PaymentprocessorInitPaymentRequest
 */
export interface PaymentprocessorInitPaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorInitPaymentRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {PaymentprocessorPaymentContext}
     * @memberof PaymentprocessorInitPaymentRequest
     */
    'context'?: PaymentprocessorPaymentContext;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorInitPaymentRequest
     */
    'code': string;
    /**
     * 
     * @type {PaymentprocessorMoney}
     * @memberof PaymentprocessorInitPaymentRequest
     */
    'amount'?: PaymentprocessorMoney;
    /**
     * 
     * @type {PaymentprocessorCurrency}
     * @memberof PaymentprocessorInitPaymentRequest
     */
    'currency'?: PaymentprocessorCurrency;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorInitPaymentRequest
     */
    'additionalInfo'?: string;
}


/**
 * 
 * @export
 * @interface PaymentprocessorInitPaymentResponse
 */
export interface PaymentprocessorInitPaymentResponse {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorInitPaymentResponse
     */
    'payload'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorInitPaymentResponse
     */
    'errorMessage'?: string;
}
/**
 * 
 * @export
 * @interface PaymentprocessorItem
 */
export interface PaymentprocessorItem {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorItem
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorItem
     */
    'productGrn'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentprocessorItem
     */
    'qtyOrdered'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentprocessorItem
     */
    'qtyCommitted'?: number;
    /**
     * 
     * @type {PaymentprocessorMoney}
     * @memberof PaymentprocessorItem
     */
    'unitSalePrice'?: PaymentprocessorMoney;
    /**
     * 
     * @type {PaymentprocessorMoney}
     * @memberof PaymentprocessorItem
     */
    'unitListPrice'?: PaymentprocessorMoney;
    /**
     * 
     * @type {PaymentprocessorMoney}
     * @memberof PaymentprocessorItem
     */
    'unitBasePrice'?: PaymentprocessorMoney;
    /**
     * 
     * @type {PaymentprocessorMoney}
     * @memberof PaymentprocessorItem
     */
    'unitVatAmount'?: PaymentprocessorMoney;
    /**
     * 
     * @type {PaymentprocessorMoney}
     * @memberof PaymentprocessorItem
     */
    'rowSalePrice'?: PaymentprocessorMoney;
    /**
     * 
     * @type {PaymentprocessorMoney}
     * @memberof PaymentprocessorItem
     */
    'rowListPrice'?: PaymentprocessorMoney;
    /**
     * 
     * @type {PaymentprocessorMoney}
     * @memberof PaymentprocessorItem
     */
    'rowVatAmount'?: PaymentprocessorMoney;
    /**
     * 
     * @type {PaymentprocessorMoney}
     * @memberof PaymentprocessorItem
     */
    'discountAmount'?: PaymentprocessorMoney;
    /**
     * 
     * @type {PaymentprocessorMoney}
     * @memberof PaymentprocessorItem
     */
    'rowBasePrice'?: PaymentprocessorMoney;
    /**
     * 
     * @type {number}
     * @memberof PaymentprocessorItem
     */
    'vatPercentage'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentprocessorItem
     */
    'vatInaccurate'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentprocessorItem
     */
    'vatCalculated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorItem
     */
    'productName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorItem
     */
    'productCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorItem
     */
    'productSku'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorItem
     */
    'productOptions'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorItem
     */
    'productImg'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorItem
     */
    'productData'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorItem
     */
    'shipmentInfoReference'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PaymentprocessorItem
     */
    'promotionGrn'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentprocessorItem
     */
    'productIsVirtual'?: boolean;
}
/**
 * 
 * @export
 * @interface PaymentprocessorListAvailablePaymentMethodsRequest
 */
export interface PaymentprocessorListAvailablePaymentMethodsRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorListAvailablePaymentMethodsRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {PaymentprocessorAvailabilityContext}
     * @memberof PaymentprocessorListAvailablePaymentMethodsRequest
     */
    'context': PaymentprocessorAvailabilityContext;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentprocessorListAvailablePaymentMethodsRequest
     */
    'authenticateMethods'?: boolean;
}
/**
 * 
 * @export
 * @interface PaymentprocessorListAvailablePaymentMethodsResponse
 */
export interface PaymentprocessorListAvailablePaymentMethodsResponse {
    /**
     * 
     * @type {Array<PaymentprocessorPaymentMethod>}
     * @memberof PaymentprocessorListAvailablePaymentMethodsResponse
     */
    'methods'?: Array<PaymentprocessorPaymentMethod>;
}
/**
 * 
 * @export
 * @interface PaymentprocessorListPaymentMethodsRequest
 */
export interface PaymentprocessorListPaymentMethodsRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorListPaymentMethodsRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentprocessorListPaymentMethodsRequest
     */
    'authenticateMethods'?: boolean;
}
/**
 * 
 * @export
 * @interface PaymentprocessorListPaymentMethodsResponse
 */
export interface PaymentprocessorListPaymentMethodsResponse {
    /**
     * 
     * @type {Array<PaymentprocessorPaymentMethod>}
     * @memberof PaymentprocessorListPaymentMethodsResponse
     */
    'methods'?: Array<PaymentprocessorPaymentMethod>;
}
/**
 * 
 * @export
 * @interface PaymentprocessorLocalizedText
 */
export interface PaymentprocessorLocalizedText {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PaymentprocessorLocalizedText
     */
    'value'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface PaymentprocessorMoney
 */
export interface PaymentprocessorMoney {
    /**
     * The whole units of the amount. For example if `currencyCode` is `\"USD\"`, then 1 unit is one US dollar.
     * @type {string}
     * @memberof PaymentprocessorMoney
     */
    'units'?: string;
    /**
     * Number of micro (10^-6) units of the amount. The value must be between -999,999 and +999,999 inclusive. If `units` is positive, `micros` must be positive or zero. If `units` is zero, `micros` can be positive, zero, or negative. If `units` is negative, `micros` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `micros`=-750,000.
     * @type {number}
     * @memberof PaymentprocessorMoney
     */
    'micros'?: number;
}
/**
 * 
 * @export
 * @interface PaymentprocessorPayment
 */
export interface PaymentprocessorPayment {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorPayment
     */
    'id': string;
    /**
     * payment type stripe, paypal..
     * @type {string}
     * @memberof PaymentprocessorPayment
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorPayment
     */
    'additionalInfo'?: string;
    /**
     * 
     * @type {Array<PaymentprocessorTransaction>}
     * @memberof PaymentprocessorPayment
     */
    'transactions'?: Array<PaymentprocessorTransaction>;
}
/**
 * 
 * @export
 * @interface PaymentprocessorPaymentContext
 */
export interface PaymentprocessorPaymentContext {
    /**
     * 
     * @type {PaymentprocessorPostalAddress}
     * @memberof PaymentprocessorPaymentContext
     */
    'billingAddress'?: PaymentprocessorPostalAddress;
    /**
     * 
     * @type {PaymentprocessorPostalAddress}
     * @memberof PaymentprocessorPaymentContext
     */
    'shippingAddress'?: PaymentprocessorPostalAddress;
    /**
     * 
     * @type {PaymentContextOrderInfo}
     * @memberof PaymentprocessorPaymentContext
     */
    'orderInfo'?: PaymentContextOrderInfo;
}
/**
 * 
 * @export
 * @interface PaymentprocessorPaymentMethod
 */
export interface PaymentprocessorPaymentMethod {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorPaymentMethod
     */
    'code': string;
    /**
     * 
     * @type {PaymentprocessorLocalizedText}
     * @memberof PaymentprocessorPaymentMethod
     */
    'title': PaymentprocessorLocalizedText;
    /**
     * 
     * @type {PaymentprocessorLocalizedText}
     * @memberof PaymentprocessorPaymentMethod
     */
    'label'?: PaymentprocessorLocalizedText;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentprocessorPaymentMethod
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {PaymentprocessorMoney}
     * @memberof PaymentprocessorPaymentMethod
     */
    'amount'?: PaymentprocessorMoney;
    /**
     * 
     * @type {PaymentprocessorCurrency}
     * @memberof PaymentprocessorPaymentMethod
     */
    'currency'?: PaymentprocessorCurrency;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorPaymentMethod
     */
    'additionalInfo'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentprocessorPaymentMethod
     */
    'isUpfront'?: boolean;
    /**
     * 
     * @type {PaymentprocessorLocalizedText}
     * @memberof PaymentprocessorPaymentMethod
     */
    'description'?: PaymentprocessorLocalizedText;
    /**
     * 
     * @type {Array<PaymentprocessorPaymentMethodRestriction>}
     * @memberof PaymentprocessorPaymentMethod
     */
    'restrictions'?: Array<PaymentprocessorPaymentMethodRestriction>;
}


/**
 * 
 * @export
 * @interface PaymentprocessorPaymentMethodRestriction
 */
export interface PaymentprocessorPaymentMethodRestriction {
    /**
     * 
     * @type {Array<PaymentprocessorPaymentMethodRestrictionCondition>}
     * @memberof PaymentprocessorPaymentMethodRestriction
     */
    'conditions'?: Array<PaymentprocessorPaymentMethodRestrictionCondition>;
}
/**
 * 
 * @export
 * @interface PaymentprocessorPaymentMethodRestrictionCondition
 */
export interface PaymentprocessorPaymentMethodRestrictionCondition {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorPaymentMethodRestrictionCondition
     */
    'contextPath'?: string;
    /**
     * 
     * @type {ConditionAction}
     * @memberof PaymentprocessorPaymentMethodRestrictionCondition
     */
    'action'?: ConditionAction;
    /**
     * 
     * @type {PaymentMethodRestrictionConditionCondition}
     * @memberof PaymentprocessorPaymentMethodRestrictionCondition
     */
    'condition'?: PaymentMethodRestrictionConditionCondition;
    /**
     * 
     * @type {Array<string>}
     * @memberof PaymentprocessorPaymentMethodRestrictionCondition
     */
    'values'?: Array<string>;
}


/**
 * 
 * @export
 * @interface PaymentprocessorPerformPaymentRequest
 */
export interface PaymentprocessorPerformPaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorPerformPaymentRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorPerformPaymentRequest
     */
    'paymentId': string;
    /**
     * 
     * @type {PaymentprocessorPaymentContext}
     * @memberof PaymentprocessorPerformPaymentRequest
     */
    'context'?: PaymentprocessorPaymentContext;
    /**
     * payment type stripe, paypal..
     * @type {string}
     * @memberof PaymentprocessorPerformPaymentRequest
     */
    'code': string;
    /**
     * 
     * @type {PaymentprocessorMoney}
     * @memberof PaymentprocessorPerformPaymentRequest
     */
    'amount'?: PaymentprocessorMoney;
    /**
     * 
     * @type {PaymentprocessorCurrency}
     * @memberof PaymentprocessorPerformPaymentRequest
     */
    'currency'?: PaymentprocessorCurrency;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorPerformPaymentRequest
     */
    'additionalInfo'?: string;
    /**
     * 
     * @type {Array<PaymentprocessorTransaction>}
     * @memberof PaymentprocessorPerformPaymentRequest
     */
    'transactions'?: Array<PaymentprocessorTransaction>;
}


/**
 * 
 * @export
 * @interface PaymentprocessorPerformPaymentResponse
 */
export interface PaymentprocessorPerformPaymentResponse {
    /**
     * 
     * @type {boolean}
     * @memberof PaymentprocessorPerformPaymentResponse
     */
    'isUpfront'?: boolean;
}
/**
 * 
 * @export
 * @interface PaymentprocessorPerformRefundRequest
 */
export interface PaymentprocessorPerformRefundRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorPerformRefundRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorPerformRefundRequest
     */
    'refundId': string;
    /**
     * 
     * @type {PaymentprocessorPayment}
     * @memberof PaymentprocessorPerformRefundRequest
     */
    'payment': PaymentprocessorPayment;
    /**
     * 
     * @type {PaymentprocessorMoney}
     * @memberof PaymentprocessorPerformRefundRequest
     */
    'amount'?: PaymentprocessorMoney;
    /**
     * 
     * @type {PaymentprocessorCurrency}
     * @memberof PaymentprocessorPerformRefundRequest
     */
    'currency'?: PaymentprocessorCurrency;
}


/**
 * Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains).  In typical usage an address would be created via user input or from importing existing data, depending on the type of process.  Advice on address input / editing:  - Use an i18n-ready address widget such as    https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of   fields outside countries where that field is used.  For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478
 * @export
 * @interface PaymentprocessorPostalAddress
 */
export interface PaymentprocessorPostalAddress {
    /**
     * The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision.  All new revisions **must** be backward compatible with old revisions.
     * @type {number}
     * @memberof PaymentprocessorPostalAddress
     */
    'revision'?: number;
    /**
     * Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: \"CH\" for Switzerland.
     * @type {string}
     * @memberof PaymentprocessorPostalAddress
     */
    'regionCode'?: string;
    /**
     * Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address\' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations.  If this value is not known, it should be omitted (rather than specifying a possibly incorrect default).  Examples: \"zh-Hant\", \"ja\", \"ja-Latn\", \"en\".
     * @type {string}
     * @memberof PaymentprocessorPostalAddress
     */
    'languageCode'?: string;
    /**
     * Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
     * @type {string}
     * @memberof PaymentprocessorPostalAddress
     */
    'postalCode'?: string;
    /**
     * Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like \"CEDEX\", optionally followed by a number (e.g. \"CEDEX 7\"), or just a number alone, representing the \"sector code\" (Jamaica), \"delivery area indicator\" (Malawi) or \"post office indicator\" (e.g. CÃ´te d\'Ivoire).
     * @type {string}
     * @memberof PaymentprocessorPostalAddress
     */
    'sortingCode'?: string;
    /**
     * Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. \"Barcelona\" and not \"Catalonia\"). Many countries don\'t use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
     * @type {string}
     * @memberof PaymentprocessorPostalAddress
     */
    'administrativeArea'?: string;
    /**
     * Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
     * @type {string}
     * @memberof PaymentprocessorPostalAddress
     */
    'locality'?: string;
    /**
     * Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
     * @type {string}
     * @memberof PaymentprocessorPostalAddress
     */
    'sublocality'?: string;
    /**
     * Unstructured address lines describing the lower levels of an address.  Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. \"Austin, TX\"), it is important that the line order is clear. The order of address lines should be \"envelope order\" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. \"ja\" for large-to-small ordering and \"ja-Latn\" or \"en\" for small-to-large). This way, the most specific line of an address can be selected based on the language.  The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved.  Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
     * @type {Array<string>}
     * @memberof PaymentprocessorPostalAddress
     */
    'addressLines'?: Array<string>;
    /**
     * Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain \"care of\" information.
     * @type {Array<string>}
     * @memberof PaymentprocessorPostalAddress
     */
    'recipients'?: Array<string>;
    /**
     * Optional. The name of the organization at the address.
     * @type {string}
     * @memberof PaymentprocessorPostalAddress
     */
    'organization'?: string;
    /**
     * Optional.
     * @type {string}
     * @memberof PaymentprocessorPostalAddress
     */
    'phoneNumber'?: string;
    /**
     * Optional.
     * @type {object}
     * @memberof PaymentprocessorPostalAddress
     */
    'additionalInfo'?: object;
}
/**
 * 
 * @export
 * @interface PaymentprocessorTransaction
 */
export interface PaymentprocessorTransaction {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorTransaction
     */
    'paymentId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorTransaction
     */
    'id': string;
    /**
     * 
     * @type {PaymentprocessorTransactionType}
     * @memberof PaymentprocessorTransaction
     */
    'type'?: PaymentprocessorTransactionType;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorTransaction
     */
    'additionalInfo'?: string;
    /**
     * 
     * @type {Array<PaymentprocessorTransaction>}
     * @memberof PaymentprocessorTransaction
     */
    'childTransactions'?: Array<PaymentprocessorTransaction>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PaymentprocessorTransactionType = {
    Unknown: 'UNKNOWN',
    Authorization: 'AUTHORIZATION',
    Capture: 'CAPTURE',
    Sale: 'SALE',
    Refund: 'REFUND',
    Void: 'VOID',
    Failed: 'FAILED',
    Pending: 'PENDING',
    Fraud: 'FRAUD'
} as const;

export type PaymentprocessorTransactionType = typeof PaymentprocessorTransactionType[keyof typeof PaymentprocessorTransactionType];


/**
 * 
 * @export
 * @interface PaymentprocessorUpdatePaymentMethodRequest
 */
export interface PaymentprocessorUpdatePaymentMethodRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorUpdatePaymentMethodRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorUpdatePaymentMethodRequest
     */
    'code': string;
    /**
     * 
     * @type {PaymentprocessorLocalizedText}
     * @memberof PaymentprocessorUpdatePaymentMethodRequest
     */
    'title'?: PaymentprocessorLocalizedText;
    /**
     * 
     * @type {PaymentprocessorLocalizedText}
     * @memberof PaymentprocessorUpdatePaymentMethodRequest
     */
    'label'?: PaymentprocessorLocalizedText;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentprocessorUpdatePaymentMethodRequest
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {PaymentprocessorMoney}
     * @memberof PaymentprocessorUpdatePaymentMethodRequest
     */
    'amount'?: PaymentprocessorMoney;
    /**
     * 
     * @type {PaymentprocessorCurrency}
     * @memberof PaymentprocessorUpdatePaymentMethodRequest
     */
    'currency'?: PaymentprocessorCurrency;
    /**
     * 
     * @type {object}
     * @memberof PaymentprocessorUpdatePaymentMethodRequest
     */
    'configuration'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentprocessorUpdatePaymentMethodRequest
     */
    'isUpfront'?: boolean;
    /**
     * 
     * @type {PaymentprocessorLocalizedText}
     * @memberof PaymentprocessorUpdatePaymentMethodRequest
     */
    'description'?: PaymentprocessorLocalizedText;
    /**
     * 
     * @type {Array<PaymentprocessorPaymentMethodRestriction>}
     * @memberof PaymentprocessorUpdatePaymentMethodRequest
     */
    'restrictions'?: Array<PaymentprocessorPaymentMethodRestriction>;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorUpdatePaymentMethodRequest
     */
    'fieldMask'?: string;
}


/**
 * 
 * @export
 * @interface PaymentprocessorUpdatePaymentRequest
 */
export interface PaymentprocessorUpdatePaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorUpdatePaymentRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorUpdatePaymentRequest
     */
    'paymentId': string;
    /**
     * payment type stripe, paypal..
     * @type {string}
     * @memberof PaymentprocessorUpdatePaymentRequest
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorUpdatePaymentRequest
     */
    'additionalInfo'?: string;
    /**
     * 
     * @type {Array<PaymentprocessorTransaction>}
     * @memberof PaymentprocessorUpdatePaymentRequest
     */
    'transactions'?: Array<PaymentprocessorTransaction>;
}
/**
 * 
 * @export
 * @interface PaymentprocessorVoidPaymentRequest
 */
export interface PaymentprocessorVoidPaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorVoidPaymentRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorVoidPaymentRequest
     */
    'paymentId'?: string;
    /**
     * payment type stripe, paypal..
     * @type {string}
     * @memberof PaymentprocessorVoidPaymentRequest
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorVoidPaymentRequest
     */
    'additionalInfo'?: string;
    /**
     * 
     * @type {Array<PaymentprocessorTransaction>}
     * @memberof PaymentprocessorVoidPaymentRequest
     */
    'transactions'?: Array<PaymentprocessorTransaction>;
}
/**
 * 
 * @export
 * @interface PaymentprocessorVoidPaymentResponse
 */
export interface PaymentprocessorVoidPaymentResponse {
    /**
     * 
     * @type {PaymentprocessorTransaction}
     * @memberof PaymentprocessorVoidPaymentResponse
     */
    'transaction'?: PaymentprocessorTransaction;
    /**
     * 
     * @type {string}
     * @memberof PaymentprocessorVoidPaymentResponse
     */
    'errorMessage'?: string;
}
/**
 * 
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ProtobufAny
     */
    '@type'?: string;
}
/**
 * `NullValue` is a singleton enumeration to represent the null value for the `Value` type union.   The JSON representation for `NullValue` is JSON `null`.   - NULL_VALUE: Null value.
 * @export
 * @enum {string}
 */

export const ProtobufNullValue = {
    NullValue: 'NULL_VALUE'
} as const;

export type ProtobufNullValue = typeof ProtobufNullValue[keyof typeof ProtobufNullValue];


/**
 * 
 * @export
 * @interface RpcStatus
 */
export interface RpcStatus {
    /**
     * 
     * @type {number}
     * @memberof RpcStatus
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof RpcStatus
     */
    'message'?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof RpcStatus
     */
    'details'?: Array<ProtobufAny>;
}

/**
 * PaymentprocessorApi - axios parameter creator
 * @export
 */
export const PaymentprocessorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authorize Payment
         * @param {PaymentprocessorAuthorizePaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizePayment: async (body: PaymentprocessorAuthorizePaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('authorizePayment', 'body', body)
            const localVarPath = `/paymentprocessor.Paymentprocessor/AuthorizePayment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Payment Method
         * @param {PaymentprocessorCreatePaymentMethodRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethod: async (body: PaymentprocessorCreatePaymentMethodRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createPaymentMethod', 'body', body)
            const localVarPath = `/paymentprocessor.Paymentprocessor/CreatePaymentMethod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finalize Payment
         * @param {PaymentprocessorFinalizePaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizePayment: async (body: PaymentprocessorFinalizePaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('finalizePayment', 'body', body)
            const localVarPath = `/paymentprocessor.Paymentprocessor/FinalizePayment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Available Payment Method
         * @param {PaymentprocessorGetAvailablePaymentMethodRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailablePaymentMethod: async (body: PaymentprocessorGetAvailablePaymentMethodRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('getAvailablePaymentMethod', 'body', body)
            const localVarPath = `/paymentprocessor.Paymentprocessor/GetAvailablePaymentMethod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Payment Method
         * @param {PaymentprocessorGetPaymentMethodRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod: async (body: PaymentprocessorGetPaymentMethodRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('getPaymentMethod', 'body', body)
            const localVarPath = `/paymentprocessor.Paymentprocessor/GetPaymentMethod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Payment Method Configuration
         * @param {PaymentprocessorGetPaymentMethodConfigurationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodConfiguration: async (body: PaymentprocessorGetPaymentMethodConfigurationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('getPaymentMethodConfiguration', 'body', body)
            const localVarPath = `/paymentprocessor.Paymentprocessor/GetPaymentMethodConfiguration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Init Payment
         * @param {PaymentprocessorInitPaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initPayment: async (body: PaymentprocessorInitPaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('initPayment', 'body', body)
            const localVarPath = `/paymentprocessor.Paymentprocessor/InitPayment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Available Payment Methods
         * @param {PaymentprocessorListAvailablePaymentMethodsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailablePaymentMethods: async (body: PaymentprocessorListAvailablePaymentMethodsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('listAvailablePaymentMethods', 'body', body)
            const localVarPath = `/paymentprocessor.Paymentprocessor/ListAvailablePaymentMethods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Payment Methods
         * @param {PaymentprocessorListPaymentMethodsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentMethods: async (body: PaymentprocessorListPaymentMethodsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('listPaymentMethods', 'body', body)
            const localVarPath = `/paymentprocessor.Paymentprocessor/ListPaymentMethods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform Payment
         * @param {PaymentprocessorPerformPaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performPayment: async (body: PaymentprocessorPerformPaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('performPayment', 'body', body)
            const localVarPath = `/paymentprocessor.Paymentprocessor/PerformPayment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform Refund
         * @param {PaymentprocessorPerformRefundRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performRefund: async (body: PaymentprocessorPerformRefundRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('performRefund', 'body', body)
            const localVarPath = `/paymentprocessor.Paymentprocessor/PerformRefund`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Payment
         * @param {PaymentprocessorUpdatePaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePayment: async (body: PaymentprocessorUpdatePaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updatePayment', 'body', body)
            const localVarPath = `/paymentprocessor.Paymentprocessor/UpdatePayment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Payment Method
         * @param {PaymentprocessorUpdatePaymentMethodRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentMethod: async (body: PaymentprocessorUpdatePaymentMethodRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updatePaymentMethod', 'body', body)
            const localVarPath = `/paymentprocessor.Paymentprocessor/UpdatePaymentMethod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Void Payment
         * @param {PaymentprocessorVoidPaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidPayment: async (body: PaymentprocessorVoidPaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('voidPayment', 'body', body)
            const localVarPath = `/paymentprocessor.Paymentprocessor/VoidPayment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentprocessorApi - functional programming interface
 * @export
 */
export const PaymentprocessorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentprocessorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Authorize Payment
         * @param {PaymentprocessorAuthorizePaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizePayment(body: PaymentprocessorAuthorizePaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentprocessorAuthorizePaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizePayment(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentprocessorApi.authorizePayment']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create Payment Method
         * @param {PaymentprocessorCreatePaymentMethodRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentMethod(body: PaymentprocessorCreatePaymentMethodRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentprocessorPaymentMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentMethod(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentprocessorApi.createPaymentMethod']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Finalize Payment
         * @param {PaymentprocessorFinalizePaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finalizePayment(body: PaymentprocessorFinalizePaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentprocessorFinalizePaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finalizePayment(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentprocessorApi.finalizePayment']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Available Payment Method
         * @param {PaymentprocessorGetAvailablePaymentMethodRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailablePaymentMethod(body: PaymentprocessorGetAvailablePaymentMethodRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentprocessorPaymentMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailablePaymentMethod(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentprocessorApi.getAvailablePaymentMethod']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Payment Method
         * @param {PaymentprocessorGetPaymentMethodRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethod(body: PaymentprocessorGetPaymentMethodRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentprocessorPaymentMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethod(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentprocessorApi.getPaymentMethod']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Payment Method Configuration
         * @param {PaymentprocessorGetPaymentMethodConfigurationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethodConfiguration(body: PaymentprocessorGetPaymentMethodConfigurationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentprocessorGetPaymentMethodConfigurationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethodConfiguration(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentprocessorApi.getPaymentMethodConfiguration']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Init Payment
         * @param {PaymentprocessorInitPaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initPayment(body: PaymentprocessorInitPaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentprocessorInitPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initPayment(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentprocessorApi.initPayment']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary List Available Payment Methods
         * @param {PaymentprocessorListAvailablePaymentMethodsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAvailablePaymentMethods(body: PaymentprocessorListAvailablePaymentMethodsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentprocessorListAvailablePaymentMethodsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAvailablePaymentMethods(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentprocessorApi.listAvailablePaymentMethods']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary List Payment Methods
         * @param {PaymentprocessorListPaymentMethodsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPaymentMethods(body: PaymentprocessorListPaymentMethodsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentprocessorListPaymentMethodsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPaymentMethods(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentprocessorApi.listPaymentMethods']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Perform Payment
         * @param {PaymentprocessorPerformPaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async performPayment(body: PaymentprocessorPerformPaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentprocessorPerformPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.performPayment(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentprocessorApi.performPayment']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Perform Refund
         * @param {PaymentprocessorPerformRefundRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async performRefund(body: PaymentprocessorPerformRefundRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.performRefund(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentprocessorApi.performRefund']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update Payment
         * @param {PaymentprocessorUpdatePaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePayment(body: PaymentprocessorUpdatePaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePayment(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentprocessorApi.updatePayment']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update Payment Method
         * @param {PaymentprocessorUpdatePaymentMethodRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePaymentMethod(body: PaymentprocessorUpdatePaymentMethodRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentprocessorPaymentMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePaymentMethod(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentprocessorApi.updatePaymentMethod']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Void Payment
         * @param {PaymentprocessorVoidPaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidPayment(body: PaymentprocessorVoidPaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentprocessorVoidPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voidPayment(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentprocessorApi.voidPayment']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PaymentprocessorApi - factory interface
 * @export
 */
export const PaymentprocessorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentprocessorApiFp(configuration)
    return {
        /**
         * 
         * @summary Authorize Payment
         * @param {PaymentprocessorAuthorizePaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizePayment(body: PaymentprocessorAuthorizePaymentRequest, options?: any): AxiosPromise<PaymentprocessorAuthorizePaymentResponse> {
            return localVarFp.authorizePayment(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Payment Method
         * @param {PaymentprocessorCreatePaymentMethodRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethod(body: PaymentprocessorCreatePaymentMethodRequest, options?: any): AxiosPromise<PaymentprocessorPaymentMethod> {
            return localVarFp.createPaymentMethod(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Finalize Payment
         * @param {PaymentprocessorFinalizePaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizePayment(body: PaymentprocessorFinalizePaymentRequest, options?: any): AxiosPromise<PaymentprocessorFinalizePaymentResponse> {
            return localVarFp.finalizePayment(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Available Payment Method
         * @param {PaymentprocessorGetAvailablePaymentMethodRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailablePaymentMethod(body: PaymentprocessorGetAvailablePaymentMethodRequest, options?: any): AxiosPromise<PaymentprocessorPaymentMethod> {
            return localVarFp.getAvailablePaymentMethod(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Payment Method
         * @param {PaymentprocessorGetPaymentMethodRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod(body: PaymentprocessorGetPaymentMethodRequest, options?: any): AxiosPromise<PaymentprocessorPaymentMethod> {
            return localVarFp.getPaymentMethod(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Payment Method Configuration
         * @param {PaymentprocessorGetPaymentMethodConfigurationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodConfiguration(body: PaymentprocessorGetPaymentMethodConfigurationRequest, options?: any): AxiosPromise<PaymentprocessorGetPaymentMethodConfigurationResponse> {
            return localVarFp.getPaymentMethodConfiguration(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Init Payment
         * @param {PaymentprocessorInitPaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initPayment(body: PaymentprocessorInitPaymentRequest, options?: any): AxiosPromise<PaymentprocessorInitPaymentResponse> {
            return localVarFp.initPayment(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Available Payment Methods
         * @param {PaymentprocessorListAvailablePaymentMethodsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailablePaymentMethods(body: PaymentprocessorListAvailablePaymentMethodsRequest, options?: any): AxiosPromise<PaymentprocessorListAvailablePaymentMethodsResponse> {
            return localVarFp.listAvailablePaymentMethods(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Payment Methods
         * @param {PaymentprocessorListPaymentMethodsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentMethods(body: PaymentprocessorListPaymentMethodsRequest, options?: any): AxiosPromise<PaymentprocessorListPaymentMethodsResponse> {
            return localVarFp.listPaymentMethods(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Perform Payment
         * @param {PaymentprocessorPerformPaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performPayment(body: PaymentprocessorPerformPaymentRequest, options?: any): AxiosPromise<PaymentprocessorPerformPaymentResponse> {
            return localVarFp.performPayment(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Perform Refund
         * @param {PaymentprocessorPerformRefundRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performRefund(body: PaymentprocessorPerformRefundRequest, options?: any): AxiosPromise<object> {
            return localVarFp.performRefund(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Payment
         * @param {PaymentprocessorUpdatePaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePayment(body: PaymentprocessorUpdatePaymentRequest, options?: any): AxiosPromise<object> {
            return localVarFp.updatePayment(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Payment Method
         * @param {PaymentprocessorUpdatePaymentMethodRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentMethod(body: PaymentprocessorUpdatePaymentMethodRequest, options?: any): AxiosPromise<PaymentprocessorPaymentMethod> {
            return localVarFp.updatePaymentMethod(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Void Payment
         * @param {PaymentprocessorVoidPaymentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidPayment(body: PaymentprocessorVoidPaymentRequest, options?: any): AxiosPromise<PaymentprocessorVoidPaymentResponse> {
            return localVarFp.voidPayment(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentprocessorApi - object-oriented interface
 * @export
 * @class PaymentprocessorApi
 * @extends {BaseAPI}
 */
export class PaymentprocessorApi extends BaseAPI {
    /**
     * 
     * @summary Authorize Payment
     * @param {PaymentprocessorAuthorizePaymentRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentprocessorApi
     */
    public authorizePayment(body: PaymentprocessorAuthorizePaymentRequest, options?: RawAxiosRequestConfig) {
        return PaymentprocessorApiFp(this.configuration).authorizePayment(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Payment Method
     * @param {PaymentprocessorCreatePaymentMethodRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentprocessorApi
     */
    public createPaymentMethod(body: PaymentprocessorCreatePaymentMethodRequest, options?: RawAxiosRequestConfig) {
        return PaymentprocessorApiFp(this.configuration).createPaymentMethod(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Finalize Payment
     * @param {PaymentprocessorFinalizePaymentRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentprocessorApi
     */
    public finalizePayment(body: PaymentprocessorFinalizePaymentRequest, options?: RawAxiosRequestConfig) {
        return PaymentprocessorApiFp(this.configuration).finalizePayment(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Available Payment Method
     * @param {PaymentprocessorGetAvailablePaymentMethodRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentprocessorApi
     */
    public getAvailablePaymentMethod(body: PaymentprocessorGetAvailablePaymentMethodRequest, options?: RawAxiosRequestConfig) {
        return PaymentprocessorApiFp(this.configuration).getAvailablePaymentMethod(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Payment Method
     * @param {PaymentprocessorGetPaymentMethodRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentprocessorApi
     */
    public getPaymentMethod(body: PaymentprocessorGetPaymentMethodRequest, options?: RawAxiosRequestConfig) {
        return PaymentprocessorApiFp(this.configuration).getPaymentMethod(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Payment Method Configuration
     * @param {PaymentprocessorGetPaymentMethodConfigurationRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentprocessorApi
     */
    public getPaymentMethodConfiguration(body: PaymentprocessorGetPaymentMethodConfigurationRequest, options?: RawAxiosRequestConfig) {
        return PaymentprocessorApiFp(this.configuration).getPaymentMethodConfiguration(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Init Payment
     * @param {PaymentprocessorInitPaymentRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentprocessorApi
     */
    public initPayment(body: PaymentprocessorInitPaymentRequest, options?: RawAxiosRequestConfig) {
        return PaymentprocessorApiFp(this.configuration).initPayment(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Available Payment Methods
     * @param {PaymentprocessorListAvailablePaymentMethodsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentprocessorApi
     */
    public listAvailablePaymentMethods(body: PaymentprocessorListAvailablePaymentMethodsRequest, options?: RawAxiosRequestConfig) {
        return PaymentprocessorApiFp(this.configuration).listAvailablePaymentMethods(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Payment Methods
     * @param {PaymentprocessorListPaymentMethodsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentprocessorApi
     */
    public listPaymentMethods(body: PaymentprocessorListPaymentMethodsRequest, options?: RawAxiosRequestConfig) {
        return PaymentprocessorApiFp(this.configuration).listPaymentMethods(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Perform Payment
     * @param {PaymentprocessorPerformPaymentRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentprocessorApi
     */
    public performPayment(body: PaymentprocessorPerformPaymentRequest, options?: RawAxiosRequestConfig) {
        return PaymentprocessorApiFp(this.configuration).performPayment(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Perform Refund
     * @param {PaymentprocessorPerformRefundRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentprocessorApi
     */
    public performRefund(body: PaymentprocessorPerformRefundRequest, options?: RawAxiosRequestConfig) {
        return PaymentprocessorApiFp(this.configuration).performRefund(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Payment
     * @param {PaymentprocessorUpdatePaymentRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentprocessorApi
     */
    public updatePayment(body: PaymentprocessorUpdatePaymentRequest, options?: RawAxiosRequestConfig) {
        return PaymentprocessorApiFp(this.configuration).updatePayment(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Payment Method
     * @param {PaymentprocessorUpdatePaymentMethodRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentprocessorApi
     */
    public updatePaymentMethod(body: PaymentprocessorUpdatePaymentMethodRequest, options?: RawAxiosRequestConfig) {
        return PaymentprocessorApiFp(this.configuration).updatePaymentMethod(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Void Payment
     * @param {PaymentprocessorVoidPaymentRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentprocessorApi
     */
    public voidPayment(body: PaymentprocessorVoidPaymentRequest, options?: RawAxiosRequestConfig) {
        return PaymentprocessorApiFp(this.configuration).voidPayment(body, options).then((request) => request(this.axios, this.basePath));
    }
}



